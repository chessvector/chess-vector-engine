searchState.loadedDescShard("chess_vector_engine", 0, "Chess Vector Engine\n<strong>Chess Vector Engine</strong> - Fully open source, production-ready …\nHybrid evaluation configuration\nMaterial balance for tactical awareness\nMove recommendation data\nTraining statistics for the engine\nSelf-play with adaptive difficulty (engine gets stronger …\nAdd a position with its evaluation to the knowledge base\nAdd a move played from a position with its outcome\nAdd multiple positions in bulk for better performance\nAuto-load training data from common file names if they …\nAuto-save to database (if persistence is enabled)\nCalculate similarity between two boards\nCheck if GPU acceleration feature is available\nConfigure hybrid evaluation settings\nConfigure NNUE settings (only works if NNUE is already …\nRun continuous self-play training with periodic saving\nConvert A100 binary training data to JSON format for use …\nConvert existing JSON training files to binary format for …\nConvert existing training data to memory-mapped format for …\nConvert existing JSON training data to ultra-fast …\nConvert existing training data to ultra-compressed Zstd …\nGet database position count\nEnable LSH indexing\nEnable NNUE neural network evaluation for fast position …\nEnable NNUE with optional auto-loading of default model\nEnable NNUE with custom configuration (bypasses …\nEnable NNUE and load a specific pre-trained model\nEnable opening book with standard openings\nEnable parallel tactical search with specified number of …\nEnable persistence with database\nEnable strategic evaluation for proactive, …\nEnable aggressive strategic configuration for maximum …\nEnable strategic evaluation with default balanced …\nEnable positional strategic configuration for long-term …\nEnable strategic motif database with fast loading\nEnable tactical refinement for uncertain positions\nEnable tactical search with the given configuration\nEnable tactical search with default configuration\nEncode a position to vector (public interface)\nGet evaluation for a position using VECTOR-FIRST approach …\nNEW: Simplified evaluation method demonstrating our core …\nFind similar positions to the given board\nFind similar positions with indices for move recommendation\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate proactive moves using strategic evaluation …\nGet board position by index for motif extraction\nGet evaluation by index for motif extraction\nGet opening book entry for position\nGet position and evaluation by index for motif extraction\nGet strategic evaluation for a position (if strategic …\nGet strategic motif evaluation using motif database …\nGet current hybrid configuration\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if LSH is enabled\nDeep tactical safety verification with quiescence search\nCheck if NNUE neural network evaluation is enabled\nCheck if opening book is enabled\nCheck if position is in opening book\nCheck if parallel search is enabled\nCheck if persistence is enabled\nCheck if strategic evaluation is enabled\nCheck if tactical search is enabled\nGet the size of the knowledge base\nLoad engine state from database\nLoad Lichess puzzle database with enhanced features\nLoad Lichess puzzle database with optional limit\nLoad starter dataset for open source users\nLoad strategic motif database for instant pattern …\nLoad training data from optimized binary format (5-15x …\nUltra-fast compressed loading with zstd Zstd typically …\nLoad training data incrementally (append to existing …\nUltra-fast memory-mapped loading for instant startup Uses …\nUltra-fast MessagePack binary format loading MessagePack …\nUltra-fast streaming binary loader for massive datasets …\nUltra-fast streaming JSON loader with parallel processing …\nUltra-fast streaming JSON loader for massive datasets …\nGet LSH statistics if enabled\nMinimum number of similar positions to trust pattern …\nStrategic Motif Extraction System\nCreate a new chess vector engine with strategic motifs and …\nCreate a new chess vector engine with intelligent …\nCreate engine optimized for massive datasets (100k-1M+ …\nCreate a lightweight engine without tactical search (for …\nCreate new engine with strong tactical search …\nCreate a new engine with automatic file discovery and …\nCreate a new chess vector engine with automatic training …\nCreate a new chess vector engine with fast loading …\nCreate engine with full position database loading (legacy …\nUltra-fast instant loading - loads best available format …\nCreate a new chess vector engine with LSH enabled\nCreate engine with persistence enabled and auto-load from …\nGet opening book statistics\nConfidence threshold for pattern-only evaluation (0.0-1.0)\nWeight for pattern evaluation vs tactical evaluation …\nMacro for easy scoped timing\nQuick NNUE training if weights weren’t properly loaded\nGenerate legal move recommendations (filters …\nGet move recommendations based on similar positions and …\nRecommend moves using tactical search for safety …\nSave engine state to database using high-performance batch …\nSave engine state (positions and evaluations) to file for …\nSave training data in optimized binary format with …\nRun self-play training to generate new positions\nSet custom opening book\nCheck if the engine should play aggressively in current …\nEnhanced strategic evaluator with lazy-loaded motif …\nStrategic Motif Recognition System\nTactical search configuration\nTrain from dataset incrementally (preserves existing …\nTrain NNUE on position data (requires NNUE to be enabled)\nGet current training statistics\nUltra-fast loader for any format - optimized for massive …\nUtility modules for the chess engine\nAuto-discovery and format consolidation engine\nFile format priority (lower = better)\nTraining data file information\nClean up old format files\nGroup files by base name and select best format for each\nDiscover all training data files in a directory\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet list of inferior formats that can be cleaned up\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCache statistics for performance monitoring\nResults of our unified evaluation approach\nProduction-optimized core evaluation philosophy: Augment …\nIntelligent evaluation blender\nProduction-optimized vector similarity engine - our unique …\nResults from vector similarity analysis\nStrategic initiative analyzer - our unique differentiator …\nResults from strategic initiative analysis\nOptimized method to add position with pre-computed vector\nFast strategic analysis for high-confidence similarity …\nClear all caches (useful for benchmarking or memory …\nProduction-optimized main evaluation method with …\nFinal blended evaluation\nOptimized method using pre-computed vector (caching …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet cache statistics for monitoring\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdd a position to our knowledge base for future similarity …\nCreate a production-optimized evaluator with custom cache …\nVector similarity engine (our unique differentiator #1)\nOur unique similarity insights\nOur unique strategic insights\nTraditional tactical component (baseline)\nWhether we provided unique value beyond traditional engines\nChained error with context\nCustom error types for the chess engine with enhanced …\nCircuit breaker is open\nConfiguration error\nDatabase operation failed\nContains the error value\nFeature not available (e.g., GPU acceleration)\nInvalid chess position or move\nFile I/O operation failed\nMemory limit exceeded\nNeural network operation failed\nContains the success value\nResource exhausted (memory, time, etc.)\nOperation failed after maximum retries\nSearch operation failed or timed out\nTimeout error with details\nTraining operation failed\nValidation error with context\nVector operation failed\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEnhanced error utilities for production resilience\nCircuit breaker for failing operations\nCircuit breaker state\nMemory monitor for resource management\nConfiguration for retry operations\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRetry an operation with exponential backoff\nMain calibrated evaluator (Dependency Inversion Principle)\nConfiguration for evaluation calibration\nDetailed evaluation breakdown for analysis\nInterface for evaluation components (Interface Segregation …\nMaterial evaluation component (Single Responsibility …\nStandard centipawn values for chess pieces\nPosition evaluation component (Single Responsibility …\nAdd custom evaluation component (Open/Closed Principle)\nConvert raw pattern evaluation to calibrated centipawns\nEvaluate position in centipawns\nGet detailed evaluation breakdown\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGPU acceleration backend with intelligent device detection …\nAccelerated vector addition\nGet all available devices for multi-GPU operations\nConvert 2D ndarray to Candle tensor on the appropriate …\nConvert ndarray to Candle tensor on the appropriate device\nBenchmark the device performance\nAccelerated cosine similarity computation\nGet current device index\nGet the underlying Candle device\nGet number of available GPU devices\nGet the device type being used\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the global GPU accelerator instance (singleton pattern …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if GPU acceleration is available\nCheck if multiple GPU devices are available\nAccelerated matrix multiplication\nGet memory usage information\nMulti-GPU batch processing for large operations\nMulti-GPU parallel similarity search (when multiple GPUs …\nCreate a new GPU accelerator with intelligent device …\nSwitch to a specific device (for multi-GPU operations)\nConvert Candle tensor back to ndarray\nConvert 2D Candle tensor back to ndarray\nAccuracy record for a specific evaluator combination and …\nStatistics for adaptive learning system\nAgreement analysis between evaluators\nAnalysis depth configuration\nDynamic weights for blending evaluations\nCalibration curve types\nClarity factor for individual evaluators\nDetailed complexity analysis result\nEnhanced position complexity analyzer with detailed …\nComplexity category classification\nKey complexity factors\nWeights for different complexity factors\nConfidence analysis result with comprehensive details\nConfidence calibration settings\nConfidence categories\nDetailed confidence factors\nConfidence history entry for trend analysis\nConfidence scorer for hybrid evaluations Enhanced …\nConfidence scoring statistics\nEvaluation blender with dynamic weight computation and …\nIndividual evaluation result from a specific evaluator\nEvaluation method recommendations based on complexity …\nExtension trait for EvaluationResults to support …\nEvaluator accuracy tracker for historical confidence …\nEvaluator combination identifier\nWeights for different confidence factors\nGame phase classification\nGame phase analysis result with detailed indicators\nEnhanced game phase detector with detailed analysis and …\nAdvanced hybrid evaluation system that intelligently …\nComprehensive hybrid evaluation result\nStatistics for hybrid evaluation system\nTrait for NNUE evaluators\nPairwise agreement between two evaluators\nPattern clarity analyzer for confidence scoring\nPattern clarity analysis result\nTrait for pattern evaluators\nPhase-specific adaptation recommendations\nSettings for phase adaptation\nWeights for phase detection indicators\nIndividual phase indicator with confidence\nPhase transition states\nPosition context for confidence analysis\nReliability indicators\nTrait for strategic evaluators\nTrait for tactical evaluators\nAdaptation recommendations\nAnalyze the complexity of a chess position\nPerform detailed complexity analysis\nGet detailed game phase analysis for a position\nPerform detailed game phase analysis\nGet detailed complexity analysis for a position\nApply phase-specific adaptations to evaluation weights\nBlend evaluations using the provided weights\nWeights used for blending\nComplexity classification\nPosition complexity score (0.0 to 1.0)\nCompute dynamic blend weights based on position …\nCompute comprehensive confidence in the hybrid evaluation\nSimplified confidence computation for compatibility\nConfidence in the final evaluation (0.0 to 1.0)\nConfigure the complexity analyzer\nConfigure the game phase detector\nDetect the current game phase\nWhether endgame analysis is recommended\nEndgame tablebase priority (0.0 to 1.0)\nPerform comprehensive hybrid evaluation of a position\nEvaluation method recommendations\nTotal evaluation time in milliseconds\nRecommended evaluation weights for this phase\nFinal blended evaluation\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether result came from cache\nDetected game phase\nGet adaptive learning statistics\nGet adaptive learning statistics\nGet evaluation statistics\nGet confidence scoring statistics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKey factors contributing to complexity\nWhether king safety analysis is recommended\nIndividual complexity factors\nIndividual phase indicators\nCreate a new hybrid evaluation engine\nNNUE evaluation component\nOpening book priority (0.0 to 1.0)\nPhase scores\nOverall complexity score (0.0 to 1.0)\nPriority for pattern analysis (0.0 to 1.0)\nPattern evaluation component\nConfidence in phase detection\nWhether to prefer NNUE over other methods\nPrimary detected game phase\nWhether tactical verification is required\nSearch depth modifier (-2 to +2)\nEnable or disable adaptive weight learning\nEnable or disable adaptive learning\nPriority for strategic analysis (0.0 to 1.0)\nStrategic evaluation component\nRecommended tactical search depth\nTactical evaluation component\nTime management factor (0.5 to 2.0)\nTransition state\nUpdate historical accuracy based on actual game outcomes\nUpdate performance metrics for adaptive learning\nUpdate performance metrics based on evaluation accuracy\nCreate a phase detector with custom adaptation settings\nCreate a complexity analyzer with custom settings\nCreate a blender with custom base weights\nCreate confidence scorer with custom calibration settings\nCreate a complexity analyzer with custom weights\nRegister an NNUE evaluator\nRegister a pattern evaluator\nCreate a phase detector with custom weights\nRegister a strategic evaluator\nRegister the strategic initiative evaluator\nRegister a tactical evaluator\nHigh-performance Lichess puzzle database loader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOpen source feature: Load limited Lichess puzzles\nOpen source feature: Load limited Lichess puzzles with …\nPremium feature: Load Lichess puzzles with maximum …\nPremium feature: Load Lichess puzzles with moves for …\nLoad training data from Lichess puzzle CSV with lightning …\nLoad training data with moves from Lichess puzzle CSV for …\nCreate a new Lichess loader with default settings\nCreate a premium loader with optimized settings\nSet batch size for memory control\nSet rating range filter\nSet theme filter\nLocality Sensitive Hashing for approximate nearest …\nLSH performance statistics\nAdd a vector to the LSH index with dynamic resizing\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate LSH from database or return None if no saved …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad LSH configuration from database and rebuild hash …\nCreate a new LSH index with dynamic sizing\nFind approximate nearest neighbors\nSave LSH configuration and hash functions to database\nGet statistics about the index\nCreate a new LSH index with expected dataset size for …\nExtracts strategic motifs from a chess engine’s position …\nSimplified pattern types\nSimplified strategic pattern for cleanup phase\nExtract strategic motifs from a chess engine’s database\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new motif extractor with default parameters\nBlend weights for hybrid evaluation\nStatistics for NNUE evaluation analysis\nGame phase detection for evaluation blending\nIntegration helper for combining NNUE with vector-based …\nNNUE (Efficiently Updatable Neural Network) for chess …\nNNUE configuration optimized for chess vector engine …\nCheck if weights were loaded from file\nPerformance benchmark for NNUE evaluation\nEvaluate a position using NNUE\nBatch evaluation for multiple positions (efficient for …\nFast evaluation using pre-computed feature vectors\nAdvanced hybrid evaluation combining NNUE with …\nUltra-fast NNUE evaluation with real incremental updates\nConfiguration for research and experimentation\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet current configuration\nGet evaluation statistics for analysis\nIncremental training that preserves existing progress\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad a trained model from a file with full weight …\nCreate a new NNUE evaluator with vector integration\nCreate NNUE with optional pre-loaded weights\nConfiguration for pure NNUE evaluation (less vector …\nQuick training to fix evaluation issues when weights weren…\nRecreate the NNUE with loaded weights (workaround for …\nSave the trained model to a file with full weight …\nEnable or disable vector integration\nSet the vector evaluation blend weight\nTrain the NNUE network on position data\nUpdate NNUE after a move is made (incremental update)\nIncremental update when a move is made (NNUE efficiency …\nConfiguration optimized for hybrid vector-NNUE evaluation\nOpening book for chess positions\nStatistics about the opening book coverage\nOpening book entry containing position evaluation and …\nAdd an opening entry\nCheck if position is in opening book\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all known openings\nGet a random opening move from the starting position\nGet opening book statistics for evaluation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLook up position in opening book\nCreate a new opening book\nCreate a basic opening book with common openings\nAdvanced pattern recognition system for chess positions\nLearned pattern database\nComprehensive pattern analysis result\nPattern recognition statistics\nPattern weights for different aspects\nPattern analysis structures\nPawn structure recognizer\nOther recognizers (simplified implementations for now)\nAnalyze all patterns in a position\nCompute vector representation of patterns\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet pattern recognition statistics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new pattern recognizer\nTrain the pattern recognizer with position-evaluation pairs\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the total count of positions in the database (as usize)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad positions in batches for better memory efficiency\nSave multiple positions in a single transaction for much …\nBasic position encoder that converts chess positions to …\nCalculate similarities between a query vector and multiple …\nCalculate Euclidean distance between two vectors\nEncode a chess position into a vector (optimized version)\nEncode multiple positions in parallel\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalculate pairwise similarities between all vectors in …\nCalculate similarity between two position vectors\nGet the vector size\nHierarchical clustering node for improved search …\nStatistics about the cluster tree\nEntry in the similarity search index\nResult from similarity search (owned)\nCache entry for similarity search results with TTL\nResult from similarity search (reference-based)\nCache statistics for monitoring performance\nSimilarity search engine for chess positions with …\nStatistics about the similarity search index\nAdd a position to the search index\nBatch search optimization for multiple queries\nBrute force search (for small datasets or comparison)\nBuild hierarchical clustering tree for improved search …\nCentroid of the cluster\nChild clusters (for hierarchical clustering)\nClear all positions\nClear all caches (useful for benchmarking or memory …\nGet cluster tree statistics\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all stored positions (for LSH indexing)\nGet comprehensive cache statistics for performance …\nGet position vector by reference to avoid cloning\nGPU-accelerated similarity search for large datasets\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the index is empty\nGet all positions as references (memory efficient iterator)\nCreate a new similarity search engine with default caching …\nParallel search implementation (for larger datasets)\nParallel search implementation with references (memory …\nIndices of positions in this cluster\nCluster radius (maximum distance from centroid)\nForce rebuild of cluster tree (useful after adding many …\nReset cache statistics while preserving cached data\nSearch for k most similar positions with comprehensive …\nSearch using Euclidean distance (alternative to cosine …\nOptimized search with early termination and cached …\nSearch for k most similar positions with references …\nSequential search implementation (for small datasets)\nSequential search implementation with references (memory …\nGet number of positions in the index\nNumber of positions in this cluster (including children)\nGet statistics about the stored vectors\nCreate a new similarity search engine with custom cache …\nCategories for evaluation comparison analysis\nResult of a single position evaluation comparison\nStockfish UCI engine wrapper (Single Responsibility …\nConfiguration for Stockfish testing (Single Responsibility …\nError types for Stockfish testing (Single Responsibility …\nMain testing framework (Open/Closed Principle - extensible …\nStatistical analysis of test results (Single …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest a single position against Stockfish\nTest multiple positions and provide statistical analysis\nStrategic patterns for recognizing attacking and …\nStrategic plans for proactive play\nConfiguration for strategic evaluation emphasizing …\nResult of strategic evaluation\nStrategic evaluation system for proactive, …\nCreate aggressive strategic evaluator for maximum …\nAggressive configuration for maximum initiative and …\nBonus for pieces actively participating in attack …\nBalanced configuration for strategic play with safety …\nIntegration with existing hybrid evaluation system\nWeight for dynamic factors like tempo, development, piece …\nEnable generation of forcing moves that create imbalances\nEvaluate position strategically, focusing on initiative …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate proactive moves that seize initiative while …\nWeight for initiative and attacking chances vs positional …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBonus for controlling key squares around enemy king …\nMaster-level configuration for 2000+ ELO play\nCreate a new strategic evaluator with configuration\nCreate strategic evaluator with default balanced …\nEnable advanced pawn structure planning and pawn breaks\nWeight for piece coordination in attacks (0.0-1.0)\nPositional configuration focusing on safety and long-term …\nSafety-first configuration for solid, sound play\nCheck if position favors initiative and attacking play\nEnhanced strategic evaluation with motif insights\nEnhanced strategic evaluator with lazy-loaded strategic …\nAnalysis of strategic themes found in a position\nAnalyze position for specific strategic themes\nGet number of currently cached motifs\nClear motif caches (for memory management)\nCore strategic evaluation\nGame phase detected\nEvaluate a specific move with strategic motifs\nEvaluate position with enhanced strategic analysis …\nFind strategic motifs matching specific criteria\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet performance statistics for the lazy loading system\nGet strategic recommendations based on identified themes\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStrategic adjustment from motifs\nConfidence in motif-based recommendations\nMatched strategic motifs\nCreate new lazy strategic evaluator\nGet strategic motifs for a specific game phase (preloading …\nGet the most relevant theme in this position\nGet total number of strategic themes identified\nGet total number of available motifs\nInitiative analysis for a single color\nInitiative analyzer for individual colors\nInitiative factors for both colors\nExpected outcome of a strategic plan\nPositional pressure analysis\nPositional pressure evaluator\nStrategic initiative evaluation system that analyzes …\nStrategic initiative evaluation result\nStrategic initiative statistics\nStrategic plan\nStrategic plan generator\nTypes of strategic plans\nTime pressure factors\nTime pressure analyzer\nAnalyze initiative for a specific color\nBlack’s initiative score\nEvaluate strategic initiative for a position\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether result came from cache\nGet strategic initiative statistics\nDetailed initiative factors\nOverall initiative score (positive = white advantage)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new strategic initiative evaluator\nPositional pressure analysis\nGenerated strategic plans\nTime pressure factors\nWhite’s initiative score\nPiece activity vs opponent passivity\nMaterial advantage for white (true) or black (false)\nAny material situation\nBackward pawn weaknesses\nGood vs bad bishop evaluations\nBishop pair advantages in open positions\nSupporting types\nCastling structure integrity\nCentral control strategies\nMaterial disadvantage requires compensation for white …\nPiece coordination patterns\nTempo advantages in development\nDevelopment principles\nDoubled pawn formations\nEndgame-specific patterns\nEndgame-specific patterns\nEqual material\nGame phases for contextual relevance\nReference to a master game where this motif appeared\nHanging pawns (abreast, unsupported)\nInitiative and tempo patterns\nInitiative and tempo patterns\nIsolated pawn weaknesses\nKing activity in endgames\nKing exposure levels\nPattern matcher for king safety\nKing safety configurations\nKnight outpost on strong squares\nMaterial context for pattern relevance\nMatch result when finding motifs in a position\nTypes of strategic motifs\nOpening-specific strategic ideas\nOpening pawn breaks\nOpening-specific strategic patterns\nOpposite-side castling attack patterns\nPassed pawn advantages\nStrategic pawn breaks\nPawn chains and support structures\nPawn majority patterns\nPawn structure patterns that affect strategic evaluation\nPattern matcher for pawn structures\nPawn endgame races\nPawn shield configurations\nPawn structure patterns\nPiece coordination and placement\nPattern matcher for piece coordination\nPiece sacrifices for positional advantage\nPressure point creation\nQueen and knight coordination\nRook endgame principles\nRook lift patterns for attack\nKing safety patterns\nSpace advantage in center or wings\nContext for when a motif is most relevant\nFast strategic database for real-time pattern matching\nStatistics for the strategic database\nA strategic chess motif representing a meaningful …\nAdd a motif to the database\nConfidence in this pattern (0.0 to 1.0)\nWhen this pattern is most relevant\nHuman-readable description\nEvaluate a collection of motif matches\nStrategic evaluation adjustment (-2.0 to +2.0)\nFind strategic motifs in a position\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGame identifier (e.g., Lichess game ID)\nGame phase where this motif matters most\nGet strategic evaluation for a position\nUnique identifier for this motif\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad strategic database from binary file (ultra-fast)\nSource game references where this pattern was successful\nSpecific squares involved in this match\nMaterial balance context\nMaximum ply for relevance (None = always relevant)\nMinimum ply for relevance\nThe matched motif\nType of strategic pattern\nCreate new strategic database\nPattern hash for fast matching\nUtility functions for pattern analysis\nPly where this motif was relevant\nRating of players (for confidence weighting)\nRelevance score (0.0 to 1.0)\nGame result\nSave strategic database to binary file\nGet database statistics\nPlayer names\nDetermine game phase based on material\nGenerate pattern hash for a chess position focusing on …\nUltra-fast streaming loader for massive datasets Optimized …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUltra-fast binary format streaming loader For …\nStream-load massive JSON files with minimal memory usage …\nTactical search configuration optimized for 2000+ ELO …\nTactical search result\nFast tactical search engine for position refinement\nCreate configuration for analysis mode\nCalculate expected material exchange for a capture using …\nCheck if a piece of given type and color can attack the …\nClear transposition table\nConfiguration optimized for maximum competitive strength …\nCreate configuration optimized for competitive depth and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet complete list of all attacking pieces for SEE …\nGet all pieces that can attack a square for a given color …\nGet search statistics\nCreate configuration optimized for hybrid NNUE+pattern …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImproved Static Exchange Evaluation for capture assessment\nCreate a new tactical search engine\nCreate with default configuration\nCreate configuration optimized for speed when …\nSearch for tactical opportunities in the position with …\nUltra-fast tactical search with optimized move ordering …\nParallel search using multiple threads for root move …\nSearch with external pattern evaluation data from …\nSet external pattern evaluation data from ChessVectorEngine\nCreate configuration optimized for maximum strength …\nTraditional configuration without hybrid evaluation\nUltra-fast configuration for time-critical positions\nCreate configuration optimized for maximum speed and …\nCreate with custom transposition table size\n<strong>Advanced Self-Learning System</strong> - Continuously improves …\nEngine performance evaluator\nHigh-performance external engine process pool\nExternal engine wrapper for position evaluation\nPGN game visitor for extracting positions\nLearning progress tracking for persistent training state\nStatistics from a learning iteration\nSelf-play training configuration\nSelf-play training system for generating new positions\nTactical puzzle data from Lichess puzzle database\nTactical puzzle parser for Lichess puzzle database\nProcessed tactical training data\nTraining data point containing a position and its …\nTraining dataset manager\nAdd a single training data point\n<strong>Main Learning Loop</strong> - The core of your self-improving engine\nRemove near-duplicate positions to reduce overfitting\nFast hash-based deduplication for exact duplicates (O(n))\nRemove near-duplicate positions using parallel comparison …\nCompare engine evaluations against external engine on test …\nBatch evaluate multiple positions\nEvaluate multiple positions in parallel using concurrent …\nEvaluate a single position using external engine\nEvaluate all positions using external engine\nEvaluate all positions using external engine in parallel\nExploration factor for move selection (0.0 = greedy, 1.0 = …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nNumber of games to play per training iteration\nNumber of games to play per learning iteration\nGenerate training data through self-play games\nGet detailed progress report for testing against external …\nPosition evaluation improvement threshold\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLearning progress tracking\nLoad dataset from file\nLoad and append data from file to existing dataset …\nLoad positions from a PGN file with parallel processing\nLoad tactical training data into chess engine\nLoad tactical training data into chess engine …\nLoad learning progress from file to resume training\nLoad tactical puzzles from file\nMaximum moves per game (to prevent infinite games)\nMaximum positions to keep in memory (LRU eviction)\nMerge another dataset into this one\nStreaming deduplication when merging with existing data …\nMinimum evaluation confidence to include position\nGet the next available game ID for incremental training\nParse Lichess puzzles incrementally (preserves existing …\nParse Lichess puzzle CSV file with parallel processing\nConfidence threshold for pattern matching\nQuality threshold for keeping positions (0.0 to 1.0)\nSave dataset to file\nFast append-only save (no deduplication, just append new …\nSave incrementally (append to existing file if it exists)\nSave incrementally with option to skip deduplication\nSave learning progress to file for persistent training\nSave tactical puzzles to file for incremental loading later\nSave tactical puzzles incrementally (appends to existing …\nSplit dataset into train/test sets by games to prevent …\nTemperature for move selection (higher = more random)\nTrain the vector engine with this dataset\nWhether to use opening book for game starts\nSearch information for UCI info command\nConfiguration for the UCI engine\nUCI (Universal Chess Interface) protocol implementation …\nUCI option types\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMain UCI loop\nRun the UCI engine with default configuration\nRun the UCI engine with custom configuration\nLoading statistics\nUltra-fast loader specifically designed for massive …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet loading statistics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUltra-fast binary loader with memory mapping and parallel …\nLazy loading system for strategic motifs\nBatch cache operations for improved performance\nCache statistics\nEvaluation result cache for chess positions\nWrite-through cache for pattern data\nPattern cache statistics\nHigh-performance similarity cache for chess positions\nThread-safe LRU cache with time-based expiration\nAdd item to pending batch\nClean up expired entries\nClear all entries from the cache\nClear cache and reset statistics\nClear cache and reset statistics\nClear both cache and backing store\nClear cache and pending batch\nCheck if a key exists in cache (without updating LRU order)\nCheck if key exists (cache or backing store)\nFlush pending batch to main cache\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a value from the cache\nGet a value (checks cache first, then backing store)\nGet value from cache (including pending batch)\nGet evaluation from cache using FEN string as key\nGet similarity from cache\nInsert a value into the cache\nInsert a value (writes to both cache and backing store)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new timed LRU cache\nCreate a new similarity cache\nCreate a new evaluation cache\nCreate a new pattern cache with backing store\nCreate a new batch cache\nGet cache statistics\nGet cache statistics with hit ratio\nGet cache statistics with hit ratio\nGet cache statistics\nStore evaluation in cache\nStore similarity in cache\nLazy-loaded value that is computed on first access\nLazy collection that loads items on-demand\nStatistics for lazy collections\nStatistics for lazy dataset\nLazy file loader for large datasets\nStatistics for lazy file loader\nLazy position dataset for chess training data\nGlobal lazy resources manager\nGet cache statistics\nGet cache statistics\nClear the lazy value, forcing re-initialization on next …\nClear all resources\nClear the cache\nClear all cached files\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the value, computing it if necessary\nGet an item, loading it if necessary\nGet a resource, initializing it if necessary\nGet the global resource manager\nForce initialization without returning the value\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if an item is cached\nCheck if the value has been initialized\nLoad a file, using cache if available\nLoad positions from a file\nCreate a new lazy value\nCreate a new lazy collection\nCreate a new lazy file loader\nCreate a new lazy position dataset\nCreate a new resource manager\nPreload an item into the cache\nPreload a set of files\nRegister a lazy resource\nGet dataset statistics\nCreate a lazy collection with a cache size limit\nConfiguration for lazy loading behavior\nStatistics for monitoring lazy loading performance\nLazy-loading strategic motif database\nIndex mapping motif IDs to their file segments\nUtility for creating motif segment files\nMetadata for a motif file segment\nGet number of cached motifs\nClear all caches and reset statistics\nSplit a large collection of motifs into segment files\nCreation timestamp for cache management\nEvaluate a position against relevant strategic motifs\nFile path for this segment\nFile size in bytes\nFind motifs matching a pattern hash\nFind motifs relevant to a specific game phase\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a motif by ID, loading from disk if necessary\nGet cache statistics\nRange of motif IDs in this segment\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of motifs to keep in memory at once\nMaximum number of files to keep file handles open for\nNumber of motifs in this segment\nMap from motif ID to segment metadata\nHow long to keep unused motifs in memory (seconds)\nCreate new lazy-loading strategic database\nMap from pattern hash to motif IDs\nGame phase to relevant segment files\nPreload motifs for a specific game phase (optimization)\nGame phase this segment focuses on\nSecondary phases this segment covers\nGet total number of available motifs\nTotal number of motifs across all segments\nEnable compression for motif files\nArena allocator for temporary objects\nArena allocator statistics\nMemory-efficient batch processor\nHigh-performance memory pool for fixed-size allocations\nMemory pool statistics\nVector that uses pooled memory when available\nRAII wrapper for pooled memory\nSpecialized vector pool for ndarray operations\nAllocate a memory block\nAllocate memory from the arena\nGet a memory block for a vector of specified size\nGet arena statistics\nGet the underlying array\nGet mutable access to the underlying array\nGet a mutable slice to the memory\nGet raw pointer\nGet an immutable slice to the memory\nCreate a pooled vector with pre-allocated memory\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the global vector memory pool\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert to owned Array1\nCheck if empty\nGet the size\nCreate a new fixed-size memory pool\nCreate a new vector memory pool with common sizes\nCreate a new pooled vector\nCreate a new arena allocator\nCreate a new batch memory processor\nProcess items in batches using arena allocation\nReset the arena (mark all memory as available)\nGet size\nGet pool statistics\nGet statistics for all pools\nGet memory usage statistics\nCreate a pooled vector with pre-allocated memory\nChunked file loader for processing large files in chunks\nCompressed file loader using various compression formats\nFast position loader using memory-mapped files\nMemory-mapped file loader for ultra-fast loading of large …\nGet the raw memory-mapped data\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad binary data from a specific offset\nLoad from a compressed file (supports gzip, zstd, lz4)\nLoad positions from JSON file with streaming for large …\nLoad positions from a binary file using memory mapping\nLoad a slice of data from a specific offset\nCreate a new memory-mapped loader for a file\nCreate a new chunked loader with specified chunk size\nProcess a large file in chunks to avoid memory issues\nSave positions to a binary file for fast loading\nGet the size of the mapped file\nPool for hash maps\nPool for chess move vectors\nThread-safe object pool for reusing expensive-to-create …\nA pooled object that returns to the pool when dropped\nRAII wrapper for automatic return to pool\nTrait for resettable objects (objects that can be reused)\nPool for resettable objects\nThread-local object pool for single-threaded performance\nThread-local pooled object\nSpecialized vector pool for chess engine operations\nGlobal vector pool manager\nGet a mutable reference to the underlying vector\nGet a reference to the underlying vector\nClear the pool\nClear the pool\nClear the pool\nClear all pools\nClear all thread-local vector pools (useful for testing …\nCreate a hash map pool\nCreate a move pool\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet an object from the pool, creating one if necessary\nGet a reference to the pooled object\nGet an object from the pool\nGet a reference to the pooled object\nGet a vector from the pool (contents undefined)\nGet an object from the pool (contents undefined)\nGet a mutable reference to the pooled object\nGet a mutable reference to the pooled object\nGet or create a vector pool for a specific size\nGet a reset object from the pool\nGet a vector from the appropriate thread-local pool\nGet statistics about thread-local vector pools\nGet a zeroed vector from the pool\nGet a zeroed vector from the thread-local pool\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new object pool with a factory function\nCreate a new thread-local pool\nCreate a new vector pool\nCreate a new vector pool manager\nCreate a new pooled vector\nCreate a new resettable pool\nReset the object to its initial state\nReturn a vector to the appropriate thread-local pool\nGet the current pool size\nGet the current pool size\nGet the current pool size\nTake ownership of the vector (prevents automatic return to …\nGet the vector size\nCreate a new zeroed pooled vector\nParallel data pipeline for processing large datasets\nPerformance monitoring for parallel operations\nPerformance statistics for parallel operations\nParallel position evaluator with load balancing\nParallel batch processor for similarity searches\nHigh-performance parallel vector operations\nTask that can be executed in parallel\nWork-stealing thread pool for high-performance parallel …\nRetrieve processed results\nAdd items to the processing queue\nEvaluate positions in parallel\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet performance statistics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new work-stealing pool with specified number of …\nCreate a new parallel similarity processor\nCreate a new parallel data pipeline\nCreate a new parallel position evaluator\nCreate a new performance monitor\nParallel batch normalization\nParallel dot products for multiple vector pairs\nParallel k-nearest neighbors search\nParallel similarity matrix computation\nGet the number of pending input items\nProcess similarity searches in parallel batches\nRecord task completion for a worker\nGet the number of available results\nShutdown the thread pool\nShutdown the pipeline\nSubmit a task for parallel execution\nSimple benchmark utility\nBenchmark result\nPerformance monitoring for specific chess engine operations\nComprehensive chess engine performance report\nChess-specific performance metrics\nCounter statistics\nMemory usage snapshot\nPerformance report\nHigh-performance profiler for chess engine operations\nRAII timer for automatic timing\nTimer statistics\nEnd timing an operation\nFinish the benchmark and return results\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate comprehensive chess engine report\nGenerate a performance report\nGet all counter statistics\nGet all timer statistics\nGet chess-specific performance metrics\nGet counter statistics\nGet recent memory snapshots\nGet timer statistics\nGet the global profiler\nIncrement a counter\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRecord an iteration\nTake a memory snapshot\nCreate a new profiler\nCreate a new scoped timer\nCreate a new chess engine profiler\nPrint benchmark results\nGet the underlying profiler\nRecord evaluation metrics\nRecord search metrics\nReset all statistics\nSet a counter to a specific value\nEnable or disable profiling\nStart a new benchmark\nStart timing an operation\nTime a closure\nTime an evaluation operation\nTime a search operation\nBatch SIMD operations for processing multiple vectors at …\nSIMD-optimized vector operations for high-performance …\nAdd two vectors element-wise using SIMD instructions\nMemory-aligned vector operations for optimal SIMD …\nHigh-performance batch normalization\nCache-optimized batch similarity calculation for large …\nCompute centroid of a batch of vectors\nCompute cosine similarity using SIMD-optimized operations\nCompute dot product using SIMD instructions\nFast cosine similarity with pre-computed norms (production …\nFind the k most similar vectors to a query vector\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSIMD-optimized matrix-vector multiplication for batch …\nCompute pairwise cosine similarities between all vectors …\nScale a vector by a scalar using SIMD instructions\nCompute squared L2 norm using SIMD instructions")