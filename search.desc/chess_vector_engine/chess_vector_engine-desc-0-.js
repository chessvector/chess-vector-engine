searchState.loadedDescShard("chess_vector_engine", 0, "Chess Vector Engine\n<strong>Chess Vector Engine</strong> - Production-ready chess engine with …\nHybrid evaluation configuration\nMove recommendation data\nTraining statistics for the engine\nActivate license key\nSelf-play with adaptive difficulty (engine gets stronger …\nAdd a position with its evaluation to the knowledge base\nAdd a move played from a position with its outcome\nAuto-load training data from common file names if they …\nAuto-save to database (if persistence is enabled)\nCalculate similarity between two boards\nCheck if GPU acceleration feature is available\nCheck if feature is licensed (async version with license …\nConfigure hybrid evaluation settings\nRun continuous self-play training with periodic saving\nConvert A100 binary training data to JSON format for use …\nConvert existing JSON training files to binary format for …\nConvert existing training data to memory-mapped format for …\nConvert existing JSON training data to ultra-fast …\nConvert existing training data to ultra-compressed Zstd …\nGet database position count\nEnable LSH indexing\nEnable manifold learning with specified compression ratio\nEnable LSH for manifold space\nEnable opening book with standard openings\nEnable parallel tactical search with specified number of …\nEnable persistence with database\nEnable tactical refinement for uncertain positions\nEnable tactical search with the given configuration\nEnable tactical search with default configuration\nEncode a position to vector (public interface)\nGet evaluation for a position using hybrid approach …\nFind similar positions to the given board\nFind similar positions with indices for move recommendation\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet current feature tier\nGet opening book entry for position\nGet current hybrid configuration\nConditional compilation macros for features\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a feature is available\nCheck if LSH is enabled\nCheck if manifold learning is enabled and trained\nCheck if opening book is enabled\nCheck if position is in opening book\nCheck if parallel search is enabled\nCheck if persistence is enabled\nCheck if tactical search is enabled\nGet the size of the knowledge base\nLoad engine state from database\nLoad license cache from disk\nLoad limited Lichess puzzle database (Open Source)\nLoad Lichess puzzle database with premium features …\nLoad pre-trained manifold models from database This …\nLoad starter dataset for open source users\nLoad training data from optimized binary format (5-15x …\nUltra-fast compressed loading with zstd Zstd typically …\nLoad training data incrementally (append to existing …\nUltra-fast memory-mapped loading for instant startup Uses …\nUltra-fast MessagePack binary format loading MessagePack …\nUltra-fast streaming binary loader for massive datasets …\nUltra-fast streaming JSON loader with parallel processing …\nUltra-fast streaming JSON loader for massive datasets …\nGet LSH statistics if enabled\nGet manifold learning compression ratio\nMinimum number of similar positions to trust pattern …\nCreate a new chess vector engine\nCreate a new chess vector engine with intelligent …\nCreate engine optimized for massive datasets (100k-1M+ …\nCreate a new engine with automatic file discovery and …\nCreate a new chess vector engine with automatic training …\nCreate a new chess vector engine with fast loading …\nUltra-fast instant loading - loads best available format …\nCreate engine with license verification system\nCreate a new chess vector engine with LSH enabled\nCreate engine with offline license verification\nCreate engine with persistence enabled and auto-load from …\nCreate new engine with specific feature tier\nGet opening book statistics\nConfidence threshold for pattern-only evaluation (0.0-1.0)\nWeight for pattern evaluation vs tactical evaluation …\nGenerate legal move recommendations (filters …\nGet move recommendations based on similar positions and …\nRequire a feature (returns error if not available)\nMacro for easy feature checking\nSave license cache to disk\nSave engine state to database using high-performance batch …\nSave engine state (positions and evaluations) to file for …\nSave training data in optimized binary format with …\nRun self-play training to generate new positions\nSet custom opening book\nTactical search configuration\nTrain from dataset incrementally (preserves existing …\nTrain manifold learning on existing positions\nGet current training statistics\nUltra-fast loader for any format - optimized for massive …\nUpgrade feature tier (for license activation)\nApproximate Nearest Neighbor search using multiple …\nSearch result with similarity score\nStatistics about the ANN index\nExact search (for comparison)\nCombine multiple strategies\nUse LSH for approximate search\nUse random projections\nSearch strategies for ANN\nAdd a vector to the index\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new ANN index\nSearch for approximate nearest neighbors\nGet statistics about the index\nEnable LSH indexing\nEnable random projections for dimensionality reduction\nAuto-discovery and format consolidation engine\nFile format priority (lower = better)\nTraining data file information\nClean up old format files\nGroup files by base name and select best format for each\nDiscover all training data files in a directory\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet list of inferior formats that can be cleaned up\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRuntime feature checker\nFeature access errors\nFeature definitions and their required tiers\nAvailable feature tiers\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGPU acceleration backend with intelligent device detection …\nAccelerated vector addition\nGet all available devices for multi-GPU operations\nConvert 2D ndarray to Candle tensor on the appropriate …\nConvert ndarray to Candle tensor on the appropriate device\nBenchmark the device performance\nAccelerated cosine similarity computation\nGet current device index\nGet the underlying Candle device\nGet number of available GPU devices\nGet the device type being used\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the global GPU accelerator instance (singleton pattern …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if GPU acceleration is available\nCheck if multiple GPU devices are available\nAccelerated matrix multiplication\nGet memory usage information\nMulti-GPU batch processing for large operations\nMulti-GPU parallel similarity search (when multiple GPUs …\nCreate a new GPU accelerator with intelligent device …\nSwitch to a specific device (for multi-GPU operations)\nConvert Candle tensor back to ndarray\nConvert 2D Candle tensor back to ndarray\nLicense verification errors\nLicense key information\nLicense validation result\nMain license verifier\nEnhanced feature checker with license verification\nActivate license key\nAdd a license to the cache (for testing or manual …\nCheck if feature is available with current license\nCheck if feature is licensed for given key\nGet current Unix timestamp\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet current tier\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad license cache from file\nLoad license cache\nCreate new license verifier\nCreate new licensed feature checker\nCreate verifier in offline mode (uses only cached licenses)\nCreate offline-only checker\nSave license cache to file\nSave license cache\nVerify a license key\nHigh-performance Lichess puzzle database loader\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOpen source feature: Load limited Lichess puzzles\nOpen source feature: Load limited Lichess puzzles with …\nPremium feature: Load Lichess puzzles with maximum …\nPremium feature: Load Lichess puzzles with moves for …\nLoad training data from Lichess puzzle CSV with lightning …\nLoad training data with moves from Lichess puzzle CSV for …\nCreate a new Lichess loader with default settings\nCreate a premium loader with optimized settings\nSet batch size for memory control\nSet rating range filter\nSet theme filter\nLocality Sensitive Hashing for approximate nearest …\nLSH performance statistics\nAdd a vector to the LSH index with dynamic resizing\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate LSH from database or return None if no saved …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad LSH configuration from database and rebuild hash …\nCreate a new LSH index with dynamic sizing\nFind approximate nearest neighbors\nSave LSH configuration and hash functions to database\nGet statistics about the index\nCreate a new LSH index with expected dataset size for …\nAutoencoder for chess position manifold learning\nGet compression ratio\nDecode from manifold space to original space\nDecode multiple vectors in parallel\nEncode input to manifold space\nEncode multiple vectors in parallel\nReturns the argument unchanged.\nCreate manifold learner from database or return a new one\nInitialize the neural network architecture\nCalls <code>U::from(self)</code>.\nCheck if the network is trained\nLoad manifold learner from database\nGet the output dimension (compressed size)\nSave manifold learner configuration and weights to database\nTrain the autoencoder on position data (automatically …\nMemory-efficient training with sequential batch processing\nParallel batch training with memory efficiency and async …\nStatistics for NNUE evaluation analysis\nIntegration helper for combining NNUE with vector-based …\nNNUE (Efficiently Updatable Neural Network) for chess …\nNNUE configuration optimized for chess vector engine …\nEvaluate a position using NNUE\nHybrid evaluation combining NNUE with vector-based analysis\nConfiguration for research and experimentation\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet current configuration\nGet evaluation statistics for analysis\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad a trained model from a file\nCreate a new NNUE evaluator with vector integration\nConfiguration for pure NNUE evaluation (less vector …\nSave the trained model to a file\nEnable or disable vector integration\nSet the vector evaluation blend weight\nTrain the NNUE network on position data\nIncremental update when a move is made (NNUE efficiency …\nConfiguration optimized for hybrid vector-NNUE evaluation\nOpening book for chess positions\nOpening book statistics\nOpening book entry containing position evaluation and …\nAdd an opening entry\nCheck if position is in opening book\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all known openings\nGet a random opening move from the starting position\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLook up position in opening book\nCreate a new opening book\nGet statistics about the opening book\nCreate a basic opening book with common openings\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the total count of positions in the database (as usize)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad positions in batches for better memory efficiency\nSave multiple positions in a single transaction for much …\nBasic position encoder that converts chess positions to …\nCalculate similarities between a query vector and multiple …\nCalculate Euclidean distance between two vectors\nEncode a chess position into a vector\nEncode multiple positions in parallel\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalculate pairwise similarities between all vectors in …\nCalculate similarity between two position vectors\nGet the vector size\nEntry in the similarity search index\nResult from similarity search (owned)\nResult from similarity search (reference-based)\nSimilarity search engine for chess positions\nStatistics about the similarity search index\nAdd a position to the search index\nBrute force search (for small datasets or comparison)\nClear all positions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all stored positions (for LSH indexing)\nGet position vector by reference to avoid cloning\nGPU-accelerated similarity search for large datasets\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the index is empty\nGet all positions as references (memory efficient iterator)\nCreate a new similarity search engine\nParallel search implementation (for larger datasets)\nParallel search implementation with references (memory …\nSearch for k most similar positions (automatically chooses …\nSearch using Euclidean distance (alternative to cosine …\nSearch for k most similar positions with references …\nSequential search implementation (for small datasets)\nSequential search implementation with references (memory …\nGet number of positions in the index\nGet statistics about the stored vectors\nUltra-fast streaming loader for massive datasets Optimized …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUltra-fast binary format streaming loader For …\nStream-load massive JSON files with minimal memory usage …\nTactical search configuration\nTactical search result\nFast tactical search engine for position refinement\nClear transposition table\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet search statistics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new tactical search engine\nCreate with default configuration\nSearch for tactical opportunities in the position\nParallel search using multiple threads for root move …\nCreate with custom transposition table size\nEngine performance evaluator\nPGN game visitor for extracting positions\nSelf-play training configuration\nSelf-play training system for generating new positions\nStockfish engine wrapper for position evaluation\nHigh-performance Stockfish process pool\nTactical puzzle data from Lichess puzzle database\nTactical puzzle parser for Lichess puzzle database\nProcessed tactical training data\nTraining data point containing a position and its …\nTraining dataset manager\nAdd a single training data point\nRemove near-duplicate positions to reduce overfitting\nFast hash-based deduplication for exact duplicates (O(n))\nRemove near-duplicate positions using parallel comparison …\nCompare engine evaluations against Stockfish on test set\nBatch evaluate multiple positions\nEvaluate multiple positions in parallel using concurrent …\nEvaluate a single position using Stockfish\nEvaluate all positions using Stockfish\nEvaluate all positions using Stockfish in parallel\nExploration factor for move selection (0.0 = greedy, 1.0 = …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nNumber of games to play per training iteration\nGenerate training data through self-play games\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad dataset from file\nLoad and append data from file to existing dataset …\nLoad positions from a PGN file\nLoad tactical training data into chess engine\nLoad tactical training data into chess engine …\nLoad tactical puzzles from file\nMaximum moves per game (to prevent infinite games)\nMerge another dataset into this one\nStreaming deduplication when merging with existing data …\nMinimum evaluation confidence to include position\nGet the next available game ID for incremental training\nParse Lichess puzzles incrementally (preserves existing …\nParse Lichess puzzle CSV file with parallel processing\nSave dataset to file\nFast append-only save (no deduplication, just append new …\nSave incrementally (append to existing file if it exists)\nSave incrementally with option to skip deduplication\nSave tactical puzzles to file for incremental loading later\nSave tactical puzzles incrementally (appends to existing …\nSplit dataset into train/test sets by games to prevent …\nTemperature for move selection (higher = more random)\nTrain the vector engine with this dataset\nWhether to use opening book for game starts\nSearch information for UCI info command\nConfiguration for the UCI engine\nUCI (Universal Chess Interface) protocol implementation …\nUCI option types\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMain UCI loop\nRun the UCI engine with default configuration\nRun the UCI engine with custom configuration\nLoading statistics\nUltra-fast loader specifically designed for massive …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet loading statistics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUltra-fast binary loader with memory mapping and parallel …\nConfiguration for VAE training\nVariational Autoencoder for chess position manifold …\nConfiguration for β-VAE with higher disentanglement\nConfiguration optimized for chess positions\nCompute VAE loss (reconstruction + KL divergence)\nDecode from latent space\nEncode positions to latent space with uncertainty\nFull encoding pipeline (encode then sample)\nGet reconstruction quality metrics\nForward pass through the VAE\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate new samples from the learned manifold\nConfiguration for high compression ratio\nInitialize the VAE network with configurable architecture\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the VAE is initialized\nGet the latent dimensionality\nSample from the latent space\nTrain the VAE on a batch of position vectors")